---
title: 回顾《Microservices》系列之一：服务组件化
date: 2021-06-01 13:45:00
---
#### 背景

每隔一段时间回头看Martin老师的[microservices](https://martinfowler.com/articles/microservices.html),都多少有一些感悟和收获。因此准备分章节记录备忘，本章节对应原文的”Componentization via Services“

## 定义与价值

**组件（Component）是一个可以被单独替换或升级的软件单元**

**组件化的首要手段是把软件拆分成服务**

**把服务作为组件使用的一个重要目的是服务可以独立部署**

## 内聚与演进机制

进程内的调用关系的变更需要重新部署本应用，而进程间接口的变更意味着：

-   契约的更新
-   接口消费方的感知与通知，以及可能带来的人工沟通成本
-   调用双方的重新部署
-   向前兼容问题

在产品持续迭代中我们很难避免这种情况，而我们能做的是：

-   做好设计，让服务更加内聚、边界清晰，控制进程间调用数量
-   完善演进机制：调用关系纳入架构治理，明确影响范围；做好变更计划与淘汰计划，控制向前兼容逻辑膨胀

向前兼容引起的逻辑膨胀在无限度的对客户端版本支持的情况下非常常见（如传统APP），我们首先要做的是在维护成本变得不可接受前，把支持的客户端版本限定在一个企业可承受的范围内

## “Explicit Published Interface"

在不同号称微服务的项目中，我们不难看到那些拼装HTTP请求，然后做个工具类来调用

这种模式让服务间请求在代码逻辑上依赖该工具，并且工具类调用充斥在业务代码中，更换工具成本高

相比通过传统文档来控制契约不被破坏、降低耦合，一个暴露细节的、可发布的接口机制，可以帮助组件化调用更加简单

一个典型的实践模式就是”智能终端共享接口+哑管道集成实现“，即：

-   调用方和服务方共享一个接口（Interface），通过注解等元数据补充接口细节（比如校验规则、描述信息、实现协议等）。这样可以隐藏集成实现的选型和细节，让开发人员和代码逻辑不再关注对应的通信工具类
-   通信实现协议是HTTP、AMQP等粗粒度(coarser-grained)协议，保证对不同技术栈的支持
-   这个粗粒度协议应该是轻量的，再

这种模式的优势有：

-   由依赖注入解耦通信的实现细节，同时保证调用和实现的接口细节统一
-   可以通过CI工具，准实时更新接口规格，帮助接口文档的更新脱离手工劳作、更加高效和准确
-   开发人员直接面对接口，完全屏蔽RestTemplate、HTTPClient等工具的使用
-   通过分析工具，可以更便捷统计调用及依赖关系
-   更方便测试与Mock

该模式最明显的问题是增加了调用双方的耦合，但是请注意：服务集成本身就是一种契约的实现，而**契约本身就意味着耦合，这个耦合的价值是保证双方对契约的遵守**。接口本身只是让契约更加高效的限制调用双方不破坏封装，并且让变更更容易感知

在多技术栈团队中，调用方无法直接使用这个共享接口。但自动化工具结合统一接口描述规范（类似[OAS](https://en.wikipedia.org/wiki/OpenAPI_Specification)）可以帮助我们，这种模式：

-   使用工具根据代码生成接口描述文档
-   接口描述文档通过工具可生成不同技术栈的调用方代码

但也有需要解决的问题：

-   生成的代码可能需要二次调整才能符合团队代码规范
-   正向及逆向的”文档-代码“生成关系不同技术栈支持情况不一，特别是冷门技术栈

**技术栈多元化与标准化根据企业及团队文化而异，这对管理者来说是个不可避免的权衡与取舍。**

**而这个技术文化对于服务组件化，粗粒度通信协议的统一、以及接口契约的高效集成等原则上带来的价值，是其在微服务实践中是否应该被采纳的衡量标准**
